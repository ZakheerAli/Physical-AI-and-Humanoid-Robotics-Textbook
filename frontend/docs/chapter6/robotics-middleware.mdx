---
id: robotics-middleware
title: ROS2 Overview
---

# ROS2 Overview

The Robot Operating System (ROS) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behaviors across a wide variety of robotic platforms. ROS2 is the latest iteration of this framework, re-architected to address limitations of ROS1, particularly concerning multi-robot systems, real-time control, and embedded systems.

## Why ROS2?

ROS1, while revolutionary, had some key limitations:
*   **Single-master architecture:** A central ROS Master was a single point of failure and bottleneck, limiting multi-robot and distributed applications.
*   **Communication over TCP/IP:** Not ideal for real-time, low-latency communication required in many robotic systems.
*   **Limited support for embedded systems:** Memory and processing overhead could be too high.
*   **Security concerns:** Little native security built into the communication.

ROS2 was designed from the ground up to overcome these challenges, offering:
*   **Distributed Architecture:** No central master. Nodes communicate directly using Data Distribution Service (DDS).
*   **Improved Real-time Capabilities:** DDS provides more deterministic and efficient communication.
*   **Enhanced Multi-Robot Support:** Native support for multiple robots, each running their own ROS2 graph.
*   **Better Embedded System Integration:** More flexible and lightweight components.
*   **Security:** DDS offers built-in security features for authentication, encryption, and access control.
*   **Quality of Service (QoS):** Fine-grained control over communication reliability, latency, and throughput.

## Core Concepts of ROS2

ROS2 builds upon many of the successful concepts from ROS1 but implements them using DDS.

### Nodes

A node is an executable process that performs computations. In ROS2, nodes are independent processes that communicate with each other. A robotic system is typically composed of many nodes, each responsible for a specific function (e.g., motor control, sensor data processing, navigation).

### Topics

Topics are named buses over which nodes exchange messages. A node can *publish* messages to a topic or *subscribe* to a topic to receive messages. This publish/subscribe model is asynchronous and many-to-many.

**Example:**
*   A `camera_node` might publish image messages to the `/camera/image_raw` topic.
*   An `object_detector_node` might subscribe to `/camera/image_raw` and publish bounding box detections to `/object_detections`.

### Services

Services are a request/reply communication mechanism. A node can *offer* a service, and other nodes can *call* that service. This is a synchronous, one-to-one communication pattern, useful for requesting a specific action or piece of information.

**Example:**
*   A `navigation_node` might offer a service `set_goal` to which other nodes can send a new navigation goal. The `navigation_node` processes the request and sends back a response indicating success or failure.

### Actions

Actions are a long-running goal/feedback/result communication pattern, often used for tasks that take a significant amount of time to complete (e.g., moving a robot to a distant location, complex manipulation). An action client sends a goal to an action server, which provides continuous feedback on its progress and ultimately a result.

**Example:**
*   An action client could send a goal to a `move_base` action server to move the robot to a target (goal). The server provides feedback on the robot's current position and progress. Once the robot reaches the target, the server sends a final result (success/failure).

### Parameters

Parameters are values that configure nodes. They can be set at runtime, allowing for flexible configuration without recompiling code.

### Messages

Messages are data structures used for communication over topics, services, and actions. Each message has a defined type (e.g., `std_msgs/msg/String`, `sensor_msgs/msg/Image`).

## Data Distribution Service (DDS)

DDS is the underlying communication protocol used by ROS2. It is a middleware standard for real-time systems that provides:
*   **Discovery:** Nodes automatically find each other.
*   **Serialization:** Data is efficiently converted for transmission.
*   **Transport:** Messages are sent over the network (UDP/TCP).
*   **Quality of Service (QoS) Policies:** Configurable parameters for reliability, durability, and latency of communication.

## ROS2 Workspace

A ROS2 workspace is a directory structure that stores ROS2 package source code and build artifacts.
*   `src/`: Contains your ROS2 package source code.
*   `build/`: Stores intermediate build files.
*   `install/`: Stores installed packages (executables, libraries, configuration files).
*   `log/`: Stores log files.

To build a workspace: `colcon build`.
To source the workspace: `source install/setup.bash` (or `.ps1` for PowerShell, `.zsh` for Zsh).

ROS2 is a powerful and essential framework for modern robotics development, providing the tools and infrastructure to build complex, distributed, and real-time robotic applications.

---

# ROS2: Nodes, Topics, Services, and Actions

In ROS2, the communication architecture is built around several core concepts that allow independent processes (nodes) to collaborate and form a complex robotic system. This chapter delves deeper into Nodes, Topics, Services, and Actions, which are the fundamental building blocks for inter-process communication in ROS2.

## Nodes

A **Node** is essentially an executable program within the ROS2 ecosystem. Each node is typically designed to perform a single, well-defined task. By breaking down complex robot functionalities into smaller, modular nodes, ROS2 promotes code reusability, fault isolation, and easier debugging.

**Characteristics of Nodes:**
*   **Modular:** Encapsulates a specific functionality (e.g., a camera driver, a motor controller, a navigation algorithm).
*   **Independent:** Nodes run as separate processes and communicate via defined interfaces.
*   **Configurable:** Often accept parameters to modify their behavior without recompilation.

**Example:**
*   A `controller_node` that manages motor commands.
*   A `lidar_node` that processes data from a LiDAR sensor.
*   A `path_planner_node` that calculates trajectories for the robot.

## Topics (Publish/Subscribe Communication)

**Topics** provide a flexible, asynchronous communication mechanism based on the **publish/subscribe** pattern. Nodes publish messages to a named topic, and other nodes subscribe to that topic to receive messages. This allows for one-to-many, many-to-one, and many-to-many communication flows.

**Key Features:**
*   **Asynchronous:** Publishers send messages without waiting for subscribers to receive them.
*   **Decoupled:** Publishers and subscribers do not need to know about each other's existence.
*   **Message Types:** All messages transmitted over a topic must conform to a defined message type (e.g., `sensor_msgs/msg/LaserScan`, `std_msgs/msg/String`).

**How it Works:**
1.  A **Publisher** node creates a publisher for a specific topic and message type.
2.  The Publisher serializes and sends messages to the topic.
3.  A **Subscriber** node creates a subscriber for the same topic and message type.
4.  The Subscriber receives messages from the topic whenever they are published.

**Example:**
Imagine a robot with a camera and an object detection algorithm:
*   `camera_node`: **Publishes** `sensor_msgs/msg/Image` messages to the `/image_raw` topic.
*   `object_detection_node`: **Subscribes** to `/image_raw` and **Publishes** `vision_msgs/msg/Detection2DArray` to `/object_detections`.
*   `display_node`: **Subscribes** to `/image_raw` and `/object_detections` to visualize the camera feed with detected objects.

## Services (Request/Reply Communication)

**Services** provide a synchronous, client-server (request/reply) communication mechanism. A node can act as a **Service Server**, offering a specific functionality, and other nodes can act as **Service Clients**, sending requests to the server and waiting for a response.

**Key Features:**
*   **Synchronous:** The client blocks until it receives a response from the server.
*   **One-to-One:** A single client makes a request to a single server.
*   **Service Types:** Services define both a request message type and a response message type.

**How it Works:**
1.  A **Service Server** node advertises a service with a specific name and service type.
2.  A **Service Client** node creates a client for that service.
3.  The Client sends a **request** message to the server.
4.  The Server processes the request and sends back a **response** message.
5.  The Client receives the response.

**Example:**
*   `robot_arm_node`: **Offers** a service `/move_arm` with a `MoveArm.srv` type (request: target joint angles, response: success/failure).
*   `task_planner_node`: **Calls** the `/move_arm` service with desired joint angles to instruct the robot arm.

## Actions (Long-Running Goal-Oriented Communication)

**Actions** are designed for long-running, goal-oriented tasks that provide **periodic feedback** and a final **result**. They combine aspects of both topics and services.

**Key Features:**
*   **Asynchronous Goal:** The client sends a goal and doesn't block, but can monitor progress.
*   **Periodic Feedback:** The server sends regular updates on the goal's progress.
*   **Final Result:** The server sends a final result once the goal is completed or aborted.
*   **Preemptable:** The client can cancel an active goal.

**How it Works:**
1.  An **Action Client** sends a **goal** to an **Action Server**.
2.  The Action Server processes the goal and sends continuous **feedback** messages back to the client.
3.  The Action Client can monitor the feedback and choose to **cancel** the goal.
4.  Once the task is complete, the Action Server sends a final **result** to the client.

**Example:**
*   `navigation_action_server`: **Offers** a `NavigateToPose.action` (goal: target pose, feedback: current pose, distance to goal, result: arrived/failed).
*   `mission_planner_node`: **Sends** a `NavigateToPose` goal to the action server. While the robot moves, it **receives feedback** on the robot's progress.

These communication primitives — Nodes, Topics, Services, and Actions — form the backbone of ROS2, enabling developers to build highly distributed, flexible, and powerful robotic applications.

---

# ROS2: Launch Files

Launch files are a powerful and essential feature in ROS2 for starting and managing multiple nodes and other ROS2 processes simultaneously. They allow developers to define complex system configurations, specify node parameters, remap topics, and coordinate the startup of an entire robotic application with a single command. This chapter will introduce ROS2 launch files, their structure, and common use cases.

## Why Use Launch Files?

*   **Orchestration:** Start multiple nodes, processes, and tools (like `rviz2` or `foxglove`) with one command.
*   **Configuration:** Define parameters for nodes, making it easy to change behavior without modifying source code.
*   **Reproducibility:** Ensure consistent startup configurations across different development and deployment environments.
*   **Modularity:** Combine smaller launch files to build larger, more complex system setups.
*   **Debugging:** Easily control the logging level, output redirection, and other debugging options for individual nodes.

## Structure of ROS2 Launch Files

ROS2 launch files are typically written in Python, offering flexibility and programmatic control. They use an API that allows you to define various launch actions and entities.

A basic launch file looks like this:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_driver',
            executable='driver_node',
            name='robot_driver',
            output='screen',
            emulate_tty=True, # Required for output to appear in screen
            parameters=[
                {'robot_id': 'robot_a'},
                {'baud_rate': 115200}
            ]
        ),
        Node(
            package='my_robot_bringup',
            executable='teleop_node',
            name='teleop_keyboard',
            output='screen'
        )
    ])
```

## Key Elements in a Launch File

### `LaunchDescription`

The top-level container for all actions and entities in a launch file. It's the object that's returned by the `generate_launch_description()` function.

### `Node`

Used to launch an executable ROS2 node. Key arguments include:
*   `package`: The name of the ROS2 package the node belongs to.
*   `executable`: The name of the executable within the package.
*   `name`: (Optional) The name of the node (overrides the name defined in the executable).
*   `namespace`: (Optional) The namespace for the node and its topics/services.
*   `output`: Where the node's output goes (e.g., `'screen'`, `'log'`).
*   `emulate_tty`: `True` if output needs to be buffered line by line (common for interactive nodes).
*   `parameters`: A list of dictionaries or paths to YAML files for node-specific parameters.
*   `remappings`: A list of `('from', 'to')` tuples to remap topics or service names.

### `ExecuteProcess`

Used to execute any arbitrary shell command or external program.

```python
from launch import LaunchDescription
from launch.actions import ExecuteProcess

def generate_launch_description():
    return LaunchDescription([
        ExecuteProcess(
            cmd=['echo', 'Hello from a launch file!'],
            output='screen'
        )
    ])
```

### `IncludeLaunchDescription`

Allows you to include other launch files, promoting modularity and reusability.

```python
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    my_robot_launch_file = os.path.join(
        get_package_share_directory('my_robot_bringup'),
        'launch',
        'my_robot.launch.py'
    )

    return LaunchDescription([
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource([my_robot_launch_file])
        )
    ])
```

### `GroupAction`

Groups actions together, often for applying a common namespace or parameters to a set of nodes.

### `LogInfo`

Prints an informational message to the console during launch.

## Using Parameters in Launch Files

Parameters can be defined directly in the launch file or loaded from YAML files.

```python
# In launch file
parameters=[
    {'param_name': 'param_value'},
    os.path.join(get_package_share_directory('my_package'), 'config', 'my_params.yaml')
]
```

## Remapping Topics

Remapping allows you to change the name of a topic or service used by a node without modifying the node's source code.

```python
Node(
    package='my_sensor_pkg',
    executable='sensor_node',
    remappings=[
        ('/sensor_data', '/robot_a/sensor_data')
    ]
)
```

## Running Launch Files

To run a launch file, use the `ros2 launch` command:

```bash
ros2 launch <package_name> <launch_file_name>
```

Launch files are indispensable for managing the complexity of modern robotic systems in ROS2, providing a structured and programmatic way to define and execute your robot's software stack.

---

# ROS2: URDF & Robot Description

In robotics, accurately representing the physical and kinematic properties of a robot is crucial for simulation, visualization, motion planning, and control. The Unified Robot Description Format (URDF) is an XML format used in ROS to describe all aspects of a robot model. This chapter will delve into the structure of URDF, its components, and how it is used within ROS2 to create a comprehensive robot description.

## What is URDF?

URDF is an XML file format that allows you to describe a robot's physical structure, kinematic and dynamic properties, visual appearance, and collision geometry. It is a fundamental tool in ROS for representing robots, enabling various ROS tools and algorithms to interact with the robot model.

## Why Use URDF?

*   **Standardization:** Provides a universal way to describe robots within the ROS ecosystem.
*   **Simulation:** Used by simulators like Gazebo to create accurate virtual models of robots.
*   **Visualization:** Tools like RViz use URDF to display the robot's structure and movements.
*   **Motion Planning:** Libraries like MoveIt! use the kinematic and dynamic information from URDF for path planning.
*   **Hardware Abstraction:** A single URDF can describe a robot that might be controlled by different hardware interfaces.

## Core Components of a URDF File

A URDF file primarily consists of `link` and `joint` elements.

### `link` Element

A `link` represents a rigid body part of the robot (e.g., a wheel, a chassis, a robotic arm segment). Each link has attributes for its physical properties:

*   **`inertial`:** Describes the mass, center of mass (COM), and inertia matrix of the link. Essential for dynamic simulation.
    ```xml
    <inertial>
      <mass value="1.0"/>
      <origin xyz="0 0 0.5" rpy="0 0 0"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
    ```
*   **`visual`:** Describes the visual appearance of the link (e.g., mesh file, color). Used for rendering in visualization tools.
    ```xml
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="0.1" length="1.0"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 0.8 1"/>
      </material>
    </visual>
    ```
*   **`collision`:** Describes the collision geometry of the link. This is often a simplified representation of the visual geometry to speed up collision detection in simulations.
    ```xml
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="0.1" length="1.0"/>
      </geometry>
    </collision>
    ```

### `joint` Element

A `joint` describes the connection between two `link` elements. It defines the type of motion allowed between them and their relative position and orientation.

*   **`name`:** Unique name for the joint.
*   **`type`:** The type of joint (e.g., `revolute`, `continuous`, `prismatic`, `fixed`, `floating`, `planar`).
*   **`parent`:** The name of the parent link.
*   **`child`:** The name of the child link.
*   **`origin`:** The transformation (position `xyz` and orientation `rpy`) from the parent link's frame to the joint's frame.
    ```xml
    <joint name="base_link_to_arm_joint" type="revolute">
      <parent link="base_link"/>
      <child link="arm_link"/>
      <origin xyz="0 0 0.1" rpy="0 0 0"/>
      <axis xyz="0 0 1"/> <!-- Axis of rotation for revolute/continuous joints -->
      <limit lower="-1.57" upper="1.57" velocity="1.0" effort="10.0"/>
    </joint>
    ```
*   **`axis`:** The axis of rotation for revolute/continuous joints or translation for prismatic joints.
*   **`limit`:** Specifies the physical limits of the joint (e.g., lower/upper angle limits, velocity, effort).
*   **`dynamics`:** (Optional) Joint damping and friction coefficients.

## Xacro: Simplifying URDF

Writing complex URDF files can be tedious due to repetition. Xacro (XML Macros) is an XML macro language that allows you to use macros, properties, and mathematical expressions to simplify and parameterize URDF files, making them more readable and maintainable.

A typical Xacro file would have the `.urdf.xacro` extension. It's processed to generate a pure URDF file.

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="my_robot">

  <xacro:property name="M_PI" value="3.1415926535897931"/>
  <xacro:property name="chassis_length" value="0.5"/>

  <link name="base_link">
    <!-- ... inertial, visual, collision ... -->
  </link>

  <xacro:macro name="wheel_link" params="prefix parent_link x_offset y_offset">
    <link name="${prefix}_wheel">
      <!-- ... wheel properties ... -->
    </link>
    <joint name="${parent_link}_to_${prefix}_wheel_joint" type="continuous">
      <parent link="${parent_link}"/>
      <child link="${prefix}_wheel"/>
      <origin xyz="${x_offset} ${y_offset} 0" rpy="${-M_PI/2} 0 0"/>
      <axis xyz="0 0 1"/>
    </joint>
  </xacro:macro>

  <xacro:wheel_link prefix="left" parent_link="base_link" x_offset="-0.2" y_offset="0.2"/>
  <xacro:wheel_link prefix="right" parent_link="base_link" x_offset="-0.2" y_offset="-0.2"/>

</robot>
```

## Robot State Publisher

The `robot_state_publisher` ROS2 package reads the URDF (or Xacro) file and the current joint states (typically published by `joint_state_publisher` or directly from hardware drivers) and publishes the robot's 3D pose (transformations) as TF2 messages. These TF2 messages are crucial for visualizing the robot in RViz and for various navigation and manipulation algorithms.

## Practical Example Workflow

1.  **Design the Robot:** Sketch out the robot's physical structure, links, and joints.
2.  **Create Xacro File:** Write an `.urdf.xacro` file describing the robot.
3.  **Launch Robot Description:** Use a launch file to:
    *   Load the Xacro file and convert it to URDF (using `xacro` command).
    *   Start `robot_state_publisher` to publish the robot's transforms.
    *   Start `joint_state_publisher` (if not using hardware drivers directly) to publish dummy joint states or read from a GUI.
    *   Start `RViz2` to visualize the robot.

URDF and Xacro are indispensable tools for any ROS2 developer, providing a standardized and flexible way to define and work with robot models in a wide range of applications from simulation to real-world deployment.

---

# ROS2: Navigation Stack

The ROS Navigation Stack is a powerful and highly configurable software package that provides autonomous navigation capabilities to a mobile robot. It enables a robot to move from a starting pose to a goal pose in a cluttered environment while avoiding obstacles. This chapter will introduce the core components of the ROS2 Navigation Stack (Nav2) and explain how they work together to achieve autonomous navigation.

## Overview of Nav2 Architecture

Nav2 is built upon a modular architecture, with each component performing a specific task. The primary components include:

*   **Behavior Tree:** Orchestrates the high-level behaviors of the robot (e.g., `navigate_to_pose`, `follow_path`, `explore`).
*   **Waypoint Follower:** Executes a predefined sequence of waypoints.
*   **Global Planner:** Plans a collision-free path from the robot's start position to the goal position on a static map.
*   **Local Planner (Controller):** Controls the robot's velocity commands to follow the global path and avoid dynamic obstacles in real-time.
*   **Costmap Filters:** Modify the costmap to represent dynamic obstacles or areas to avoid.
*   **Voxel Grid:** Used for 3D obstacle representation.
*   **Recovery Behaviors:** Actions taken when the robot gets stuck or encounters an unexpected situation (e.g., `clear_costmap`, `spin`).
*   **Map Server:** Provides the static map of the environment.
*   **AMCL (Adaptive Monte Carlo Localization):** Localizes the robot within a known map using particle filters.
*   **Sensor Fusion (using `robot_localization`):** Combines data from various sensors (IMU, odometry, GPS) to provide an accurate estimate of the robot's pose.
*   **RViz2/Foxglove:** Visualization tools for monitoring the navigation process, including robot pose, map, planned paths, and obstacles.

## Key Concepts

### Map

The navigation stack relies on a map of the environment. This can be a pre-built static map (2D occupancy grid) or a dynamically generated map (SLAM).

### Global Plan

The global planner generates a path from the robot's current location to the target location on the static map. This path is usually optimal (e.g., shortest or safest) given the known environment.

### Local Plan

The local planner continuously generates a short, executable trajectory that closely follows the global plan while actively avoiding local obstacles detected by the sensors. It outputs velocity commands to the robot's base controller.

### Costmaps

Costmaps are 2D or 3D grids that represent the cost of traversing each cell in the environment.
*   **Static Layer:** Represents permanent obstacles from the map.
*   **Obstacle Layer:** Incorporates dynamic obstacles detected by sensors.
*   **Inflation Layer:** Expands obstacles to account for the robot's footprint, preventing collisions.

### Localization

Localization is the process of determining the robot's position and orientation within a map. AMCL is a common localization algorithm in Nav2.

## How the Navigation Stack Works (High-Level Flow)

1.  **Robot receives a goal pose:** This can come from a user command (e.g., RViz2) or another ROS2 node.
2.  **Localization:** AMCL (or another localization method) uses sensor data (e.g., laser scans) and the map to estimate the robot's current pose.
3.  **Global Path Planning:** A global planner (e.g., `NavFn`, `SmacPlanner`) generates a path from the current pose to the goal pose, considering the static costmap.
4.  **Local Path Planning & Control:** A local planner (e.g., `DWBController`, `TebLocalPlanner`) takes the global path and real-time sensor data to generate short, feasible trajectories. It avoids dynamic obstacles and sends velocity commands to the robot's base.
5.  **Costmap Updates:** Sensor data continuously updates the dynamic obstacle layer of the costmap.
6.  **Recovery Behaviors:** If the robot gets stuck or cannot find a valid path, recovery behaviors are triggered to try and resolve the situation.

## Configuration

Nav2 is highly configurable through YAML parameter files. You can tune various parameters for:
*   **Planners:** Adjust path generation algorithms, obstacle avoidance sensitivity.
*   **Controllers:** Fine-tune velocity control, dynamic obstacle avoidance.
*   **Costmaps:** Define inflation radii, sensor sources, clearing parameters.
*   **AMCL:** Adjust particle filter parameters for localization accuracy.

## Nav2 Example Launch File Structure

A typical Nav2 setup involves a main launch file that orchestrates various components:

```python
import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    # Get the launch directory
    nav2_bringup_dir = get_package_share_directory('nav2_bringup')
    
    # Load parameters
    param_file = os.path.join(nav2_bringup_dir, 'params', 'nav2_params.yaml')

    return LaunchDescription([
        Node(
            package='nav2_map_server',
            executable='map_server',
            name='map_server',
            output='screen',
            parameters=[{'yaml_filename': os.path.join(get_package_share_directory('my_robot_navigation'), 'maps', 'my_map.yaml')}]
        ),
        Node(
            package='nav2_amcl',
            executable='amcl',
            name='amcl',
            output='screen',
            parameters=[param_file]
        ),
        # ... other Nav2 nodes like global_planner, local_planner, behavior_tree, etc.
        # all loaded with their respective parameters.
    ])
```

The ROS2 Navigation Stack provides a robust and flexible framework for developing advanced autonomous navigation capabilities in mobile robots. Understanding its components and configuration is key to deploying intelligent robotic systems.

![Navigation Stack](/img/navigation-stack.svg)
